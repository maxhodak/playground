// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <cuda.h>
#include <time.h>

#include "MatrixMath.h"
#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace Example;

class MatrixMathHandler : virtual public MatrixMathIf {
 public:
  MatrixMathHandler() { }

  void add(std::vector<double> & _return, const std::vector<double> & a, const std::vector<double> & b) {
    if(a.length() != b.length()) {
      // throw exception.
      return;
    }

    float *a_h, *a_d, *b_h, *b_d, *c_h, *c_d;
    size_t size = a.length() * sizeof(float);
    a_h = (float *)malloc(size);
    b_h = (float *)malloc(size);
    c_h = (float *)malloc(size);

    cudaMalloc((void **) &a_d, size);
    cudaMalloc((void **) &b_d, size);
    cudaMalloc((void **) &c_d, size);

    for(std::vector<double>::const_iterator i = a.begin(); i!= a.end(); i++) {
      a_h[i] = *i;
    }

    for(std::vector<double>::const_iterator i = b.begin(); i!= b.end(); i++) {
      b_h[i] = *i;
    }

    cudaMemcpy(a_d, a_h, size, cudaMemcpyHostToDevice);
    cudaMemcpy(b_d, b_h, size, cudaMemcpyHostToDevice);

    int block_size = 4;
    int n_blocks = N/block_size + (N % block_size == 0 ? 0 : 1);
    add_vectors<<<n_blocks, block_size>>> (a_d, b_d, c_d, N);

    cudaMemcpy(c_h, c_d, sizeof(float)*N, cudaMemcpyDeviceToHost);

    for (int i=0; i<N; i++) {
      _return.push_back((double)c_h[i])
    }

    free(a_h);
    free(b_h);
    free(c_h);
    cudaFree(a_d);
    cudaFree(b_d);
    cudaFree(c_d);
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<MatrixMathHandler> handler(new MatrixMathHandler());
  shared_ptr<TProcessor> processor(new MatrixMathProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}